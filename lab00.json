{
    "Snippet_1": {
        "prefix": "snippet_1",
        "body": [
            "def bfs(graph, start, goal):",
            "    visited = set()",
            "    queue = [(start, [start])]  # Queue now stores current node and path to it",
            "    while queue:",
            "        current, path = queue.pop(0)  # Use pop(0) for BFS behavior",
            "        if current == goal:",
            "            print(\"Goal found!\")",
            "            return path",
            "",
            "        if current not in visited:",
            "            visited.add(current)",
            "            print(current, end=\" \")",
            "            # Add neighbors to queue with their paths",
            "            for neighbor in graph[current]:",
            "                if neighbor not in visited:",
            "                    new_path = path + [neighbor]",
            "                    queue.append((neighbor, new_path))",
            "    return None",
            "",
            "def dfs(graph, start, goal):",
            "    visited = set()",
            "    stack = [(start, [start])]  # Stack now stores current node and path to it",
            "    ",
            "    while stack:",
            "        current, path = stack.pop()  # Use pop() for DFS behavior",
            "        if current == goal:",
            "            print(\"Goal found!\")",
            "            return path",
            "            ",
            "        if current not in visited:",
            "            visited.add(current)",
            "            print(current, end=\" \")",
            "            ",
            "            # Add neighbors to stack with their paths",
            "            for neighbor in graph[current]:",
            "                if neighbor not in visited:",
            "                    new_path = path + [neighbor]",
            "                    stack.append((neighbor, new_path))",
            "    return None",
            "",
            "class GoalbasedAgent:",
            "    def __init__(self, start, goal, graph):",
            "        self.start = start",
            "        self.goal = goal",
            "        self.graph= graph",
            "    def act(self):",
            "        # result = dfs(self.graph, self.start, self.goal)",
            "        result = bfs(self.graph, self.start, self.goal)",
            "        return result",
            "",
            "class envir:",
            "    def __init__(self, grid):",
            "        self.grid = grid",
            "        self.graph = create_graph(grid)",
            "        self.rows = len(grid)",
            "        self.cols = len(grid[0])",
            "        self.start = self.find_position('S')",
            "        self.goal = self.find_position('K')",
            "",
            "    def find_position(self, element):",
            "        for i in range(self.rows):",
            "            for j in range(self.cols):",
            "                if self.grid[i][j] == element:",
            "                    return (i, j)",
            "        return None",
            "",
            "def create_graph(maze):",
            "    graph = {}",
            "    rows = len(maze)",
            "    cols = len(maze[0])",
            "    # print (rows, cols)",
            "    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] ",
            "    ",
            "    for i in range(rows):",
            "        for j in range(cols):",
            "            if maze[i][j] != '#' and maze[i][j] != 'F':",
            "                neig = []",
            "                for dx, dy in (directions):",
            "                    nx, ny = i+dx, j+dy",
            "                    if (0<=nx<rows and 0<=ny< cols and maze[nx][ny]!='#' and maze[i][j] != 'F'):",
            "                        neig.append((nx, ny))",
            "                graph[(i,j)]= neig",
            "    return graph",
            "",
            "def run_agent(grid):",
            "    # Initialize environment and agent",
            "    env = envir(grid)",
            "    agent = GoalbasedAgent(env.start, env.goal, env.graph)",
            "    ",
            "    # Get the path from start to goal",
            "    path = agent.act()",
            "    ",
            "    # Print the path details",
            "    print(\"\\nPath from Start to Goal:\")",
            "    for step, pos in enumerate(path):",
            "        print(f\"Step {step + 1}: {pos}\")",
            "    ",
            "    return path",
            "",
            "# Test the agent",
            "grid = [",
            "    ['S', '.', '#', '.', 'K'],",
            "    ['.', '#', '.', '#', '.'],",
            "    ['.', '.', '.', '.', '.'],",
            "    ['#', '.', '#', '.', '#'],",
            "    ['.', '.', '.', '.', '.']",
            "]",
            "",
            "",
            "result = run_agent(grid)"
        ],
        "description": "Code Snippet 1 from the notebook"
    },
    "Snippet_2": {
        "prefix": "snippet_2",
        "body": [
            "class GraphEnvironment:",
            "    def __init__(self, graph_structure):",
            "        self.graph = graph_structure",
            "        ",
            "class GraphAgent:",
            "    def __init__(self, start, goal, graph):",
            "        self.start = start",
            "        self.goal = goal",
            "        self.graph = graph",
            "        ",
            "    def act(self, method='dfs'):",
            "        if method == 'dfs':",
            "            return self.dfs()",
            "        return self.bfs()",
            "    ",
            "    def bfs(self):",
            "        visited = set()",
            "        queue = [(self.start, [self.start])]",
            "        ",
            "        while queue:",
            "            current, path = queue.pop(0)",
            "            if current == self.goal:",
            "                print(\"Goal found!\")",
            "                return path",
            "                ",
            "            if current not in visited:",
            "                visited.add(current)",
            "                print(current, end=\" \")",
            "                ",
            "                for neighbor in self.graph[current]:",
            "                    if neighbor not in visited:",
            "                        queue.append((neighbor, path + [neighbor]))",
            "        return None",
            "    ",
            "    def dfs(self):",
            "        visited = set()",
            "        stack = [(self.start, [self.start])]",
            "        ",
            "        while stack:",
            "            current, path = stack.pop()",
            "            if current == self.goal:",
            "                print(\"Goal found!\")",
            "                return path",
            "                ",
            "            if current not in visited:",
            "                visited.add(current)",
            "                print(current, end=\" \")",
            "                ",
            "                for neighbor in self.graph[current]:",
            "                    if neighbor not in visited:",
            "                        stack.append((neighbor, path + [neighbor]))",
            "        return None",
            "",
            "def run_graph_agent(graph_structure, start, goal, method='dfs'):",
            "    env = GraphEnvironment(graph_structure)",
            "    agent = GraphAgent(start, goal, env.graph)",
            "    ",
            "    print(f\"\\nRunning {method.upper()} search:\")",
            "    path = agent.act(method)",
            "    ",
            "    print(\"\\nPath from Start to Goal:\")",
            "    for step, node in enumerate(path):",
            "        print(f\"Step {step + 1}: {node}\")",
            "    ",
            "    return path",
            "",
            "# Test with your existing graph and tree",
            "graph = {",
            "    1: [2, 3],",
            "    2: [4, 5],",
            "    3: [6, 7],",
            "    4: [8, 9],",
            "    5: [10, 11],",
            "    6: [12, 13],",
            "    7: [14, 15]",
            "}",
            "",
            "tree = {",
            "    'A': ['B', 'C'],",
            "    'B': ['D', 'E'],",
            "    'C': ['F', 'G'],",
            "    'D': ['H'],",
            "    'E': [],",
            "    'F': ['I'],",
            "    'G': [],",
            "    'H': [],",
            "    'I': []",
            "}",
            "",
            "# Test with graph",
            "print(\"Testing with numeric graph:\")",
            "result_graph = run_graph_agent(graph, 1, 7)",
            "",
            "print(\"\\n\" + \"=\"*50 + \"\\n\")",
            "",
            "# Test with tree",
            "print(\"Testing with letter tree:\")",
            "result_tree = run_graph_agent(tree, 'A', 'I')"
        ],
        "description": "Code Snippet 2 from the notebook"
    },
    "Snippet_3": {
        "prefix": "snippet_3",
        "body": [
            "import heapq",
            "",
            "def generate_neighbors(pos, grid):",
            "    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right",
            "    neighbors = []",
            "    rows, cols = len(grid), len(grid[0])",
            "    ",
            "    for dx, dy in directions:",
            "        nx, ny = pos[0] + dx, pos[1] + dy",
            "        if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] != '#':",
            "            neighbors.append((nx, ny))",
            "            ",
            "    return neighbors",
            "",
            "# Update create_graph to use generate_neighbors",
            "def create_graph(maze):",
            "    graph = {}",
            "    rows = len(maze)",
            "    cols = len(maze[0])",
            "    ",
            "    for i in range(rows):",
            "        for j in range(cols):",
            "            if maze[i][j] != '#':",
            "                graph[(i,j)] = generate_neighbors((i,j), maze)",
            "    return graph",
            "",
            "def heuristic(current, goal):",
            "    return abs(current[0] - goal[0]) + abs(current[1] - goal[1])",
            "",
            "def gbfs(graph, start, goal):",
            "    priority_queue = []",
            "    heapq.heappush(priority_queue, (0, [start]))",
            "    visited = set()",
            "",
            "    while priority_queue:",
            "        _, path = heapq.heappop(priority_queue)",
            "        current = path[-1]",
            "",
            "        if current in visited:",
            "            continue",
            "",
            "        if current == goal:",
            "            return path, len(path) - 1",
            "",
            "        visited.add(current)",
            "",
            "        for neighbor in graph[current]:",
            "            if neighbor not in visited:",
            "                new_path = path + [neighbor]",
            "                heapq.heappush(priority_queue, (heuristic(neighbor, goal), new_path))",
            "",
            "    return None, 0",
            "",
            "def astar(graph, start, goal):",
            "    frontier = [(0, start, [start])]",
            "    visited = set()",
            "    g_score = {start: 0}",
            "    ",
            "    while frontier:",
            "        _, current, path = heapq.heappop(frontier)",
            "        ",
            "        if current == goal:",
            "            return path, len(path) - 1",
            "            ",
            "        if current in visited:",
            "            continue",
            "            ",
            "        visited.add(current)",
            "        ",
            "        for neighbor in graph[current]:",
            "            new_g_score = g_score[current] + 1  # Cost of moving to neighbor",
            "            ",
            "            if neighbor not in g_score or new_g_score < g_score[neighbor]:",
            "                g_score[neighbor] = new_g_score",
            "                f_score = new_g_score + heuristic(neighbor, goal)",
            "                new_path = path + [neighbor]",
            "                heapq.heappush(frontier, (f_score, neighbor, new_path))",
            "    ",
            "    return None, 0",
            "",
            "def main():",
            "    grid = [",
            "        ['S', '.', '#', '.', 'K'],",
            "        ['.', '#', '.', '#', '.'],",
            "        ['.', '.', '.', '.', '.'],",
            "        ['#', '.', '#', '.', '#'],",
            "        ['.', '.', '.', '.', '.']",
            "    ]",
            "    ",
            "    # Find start and goal positions",
            "    start = goal = None",
            "    for i in range(len(grid)):",
            "        for j in range(len(grid[0])):",
            "            if grid[i][j] == 'S':",
            "                start = (i, j)",
            "            elif grid[i][j] == 'K':",
            "                goal = (i, j)",
            "    ",
            "    # Create graph from grid",
            "    graph = create_graph(grid)",
            "    ",
            "    # Run GBFS",
            "    gbfs_path, gbfs_steps = gbfs(graph, start, goal)",
            "    print(\"\\nGreedy Best First Search:\")",
            "    print(\"Path:\", gbfs_path)",
            "    print(\"Number of steps:\", gbfs_steps)",
            "    ",
            "    # Run A*",
            "    astar_path, astar_steps = astar(graph, start, goal)",
            "    print(\"\\nA* Search:\")",
            "    print(\"Path:\", astar_path)",
            "    print(\"Number of steps:\", astar_steps)",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "description": "Code Snippet 3 from the notebook"
    },
    "Snippet_4": {
        "prefix": "snippet_4",
        "body": [
            "import random",
            "",
            "def initialize_population(size, book_count):",
            "    return [random.sample(range(book_count), book_count) for _ in range(size)]",
            "",
            "def fitness(solution):",
            "    conflicts = sum([abs(solution[i] - solution[i + 1]) == 1 for i in range(len(solution) - 1)])",
            "    return 1 / (1 + conflicts)",
            "",
            "def roulette_selection(population):",
            "    total_fitness = sum(fitness(ind) for ind in population)",
            "    probabilities = [fitness(ind) / total_fitness for ind in population]",
            "    return population[random.choices(range(len(population)), probabilities)[0]]",
            "",
            "def crossover(parent1, parent2):",
            "    point1, point2 = sorted(random.sample(range(len(parent1)), 2))",
            "    child = parent1[:point1] + parent2[point1:point2] + parent1[point2:]",
            "    return child",
            "",
            "def mutate(individual):",
            "    index = random.randint(0, len(individual) - 1)",
            "    individual[index] = random.choice(range(len(individual)))",
            "",
            "# GA Execution",
            "population_size = 5",
            "books = 5",
            "generations = 10",
            "",
            "population = initialize_population(population_size, books)",
            "",
            "for _ in range(generations):",
            "    new_population = []",
            "    for _ in range(population_size):",
            "        parent1 = roulette_selection(population)",
            "        parent2 = roulette_selection(population)",
            "        child = crossover(parent1, parent2)",
            "        mutate(child)",
            "        new_population.append(child)",
            "",
            "    population = new_population",
            "",
            "best_solution = max(population, key=fitness)",
            "print(\"Best Solution:\", best_solution)"
        ],
        "description": "Code Snippet 4 from the notebook"
    },
    "Snippet_5": {
        "prefix": "snippet_5",
        "body": [
            "import random",
            "",
            "# Example books with their widths",
            "books = [10, 5, 8, 12, 6, 9, 3, 7]",
            "POPULATION_SIZE = 50",
            "GENERATIONS = 100",
            "",
            "def create_initial_population():",
            "    population = []",
            "    for _ in range(POPULATION_SIZE):",
            "        arrangement = list(range(len(books)))",
            "        random.shuffle(arrangement)",
            "        population.append(arrangement)",
            "    return population",
            "",
            "def fitness_function(arrangement):",
            "    total_width = sum(books[i] for i in arrangement)",
            "    penalty = 0",
            "    for i in range(len(arrangement)-1):",
            "        if arrangement[i] == 0 and arrangement[i+1] != 1:",
            "            penalty += 50",
            "    return -(total_width + penalty)",
            "",
            "def roulette_selection(population):",
            "    fitness_scores = [fitness_function(individual) for individual in population]",
            "    min_fitness = min(fitness_scores)",
            "    adjusted_scores = [score - min_fitness + 1 for score in fitness_scores]",
            "    ",
            "    total_fitness = sum(adjusted_scores)",
            "    probabilities = [score/total_fitness for score in adjusted_scores]",
            "    ",
            "    selected = []",
            "    for _ in range(len(population)):",
            "        r = random.random()",
            "        cumulative_prob = 0",
            "        for i, prob in enumerate(probabilities):",
            "            cumulative_prob += prob",
            "            if r <= cumulative_prob:",
            "                selected.append(population[i].copy())",
            "                break",
            "    return selected",
            "",
            "def single_point_crossover(parent1, parent2):",
            "    if len(parent1) < 2:",
            "        return parent1, parent2",
            "    ",
            "    point = random.randint(1, len(parent1)-1)",
            "    child1 = parent1[:point] + [x for x in parent2 if x not in parent1[:point]]",
            "    child2 = parent2[:point] + [x for x in parent1 if x not in parent2[:point]]",
            "    ",
            "    return child1, child2",
            "",
            "def binary_mutation(individual):",
            "    if random.random() < 0.1:",
            "        pos1, pos2 = random.sample(range(len(individual)), 2)",
            "        individual[pos1], individual[pos2] = individual[pos2], individual[pos1]",
            "    return individual",
            "",
            "def main():",
            "    population = create_initial_population()",
            "    best_fitness = float('-inf')",
            "    best_solution = None",
            "",
            "    for generation in range(GENERATIONS):",
            "        selected = roulette_selection(population)",
            "        ",
            "        new_population = []",
            "        for i in range(0, len(selected), 2):",
            "            if i+1 < len(selected):",
            "                child1, child2 = single_point_crossover(selected[i], selected[i+1])",
            "                new_population.extend([child1, child2])",
            "            else:",
            "                new_population.append(selected[i])",
            "        ",
            "        population = [binary_mutation(individual.copy()) for individual in new_population]",
            "        ",
            "        current_best = max(population, key=fitness_function)",
            "        current_best_fitness = fitness_function(current_best)",
            "        if current_best_fitness > best_fitness:",
            "            best_fitness = current_best_fitness",
            "            best_solution = current_best",
            "        ",
            "        if generation % 10 == 0:",
            "            print(f\"Generation {generation}: Best Fitness = {-best_fitness}\")",
            "    ",
            "    print(\"\\nBest arrangement found:\")",
            "    print(\"Book order:\", best_solution)",
            "    print(\"Total width:\", -best_fitness)",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "description": "Code Snippet 5 from the notebook"
    }
}